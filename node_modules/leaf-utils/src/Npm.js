const { MessageEmbed } = require(`discord.js`);
const Discord = require('discord.js');
const functions = require('../functions');

module.exports = async (options) => {
    try {	
      if (!options.message) {
		throw new Error('Leaf-utils: message argument was not specified.');
	}
	if (typeof options.message !== 'object') {
		throw new TypeError('Leaf-utils: Invalid Discord Message was provided.');
	}

     if (!options.args) {
		throw new Error('Leaf-utils: args argument was not specified.');
	}

	if (!options.embed) options.embed = {};
	if (typeof options.embed !== 'object') {
		throw new TypeError('Leaf-utils: embed must be an object.');
	}

		if (!options.embed.title) {
		options.embed.title = '{{package}}';
	}
	if (typeof options.embed.title !== 'string') {
		throw new TypeError('Leaf-utils: embed title must be a string.');
	}

  	if (!options.embed.description) {
		options.embed.description =
			'{{package_description}}';
	}
	if (typeof options.embed.description !== 'string') {
		throw new TypeError('Leaf-utils: embed description must be a string.');
	}

if (!options.query) options.query = 'Give me a package name to search';
	if (typeof options.query !== 'string') {
		throw new TypeError('Leaf-utils: query must be a string.');
	}

  if (!options.noResult) options.noResult = 'I cant find this package';
	if (typeof options.noResult !== 'string') {
		throw new TypeError('Leaf-utils: noResult must be a string.');
	}

  if (!options.embed.color) options.embed.color = functions.randomHexColor();
	if (typeof options.embed.color !== 'string') {
		throw new TypeError('Leaf-utils: embed color must be a string.');
	}

const args = options.args
  const pkg = args.join(" ")
  if(!pkg) return options.message.reply({ content: options.query});
    

    
const fetch = require("node-fetch");
    
		const res = await fetch(`https://registry.npmjs.com/${pkg}`);
		if (res.status === 404) {
			return options.message.reply({ content: options.noResult});
		}
		const body = await res.json();
		if (body.time === undefined) {
			return options.message.reply({ content: 'package unpublished'});
		}
		const version = body.versions[body['dist-tags'].latest];

    let deps = version.dependencies ? Object.keys(version.dependencies) : null;
			let maintainers = body.maintainers.map((user) => user.name);
		
			if(maintainers.length > 10) {
				const len = maintainers.length - 10;
				maintainers = maintainers.slice(0, 10);
				maintainers.push(`...${len} more.`);
			}
		
			if(deps && deps.length > 10) {
				const len = deps.length - 10;
				deps = deps.slice(0, 10);
				deps.push(`...${len} more.`);
			}

		const embed = new MessageEmbed()
			.setColor(options.embed.color)
			.setTitle(options.embed.title
                 .replace('{{package}}', pkg))
			.setURL(`https://www.npmjs.com/package/${pkg}`)
			.setDescription(options.embed.description
                 .replace('{{package_description}}', body.description) || 'No description.')
			.addField('Version', body['dist-tags'].latest, true)
			.addField('License', body.license || 'None', true)
			.addField('Author', body.author ? body.author.name : 'Unknown', true)
      .addField('Modified', `${new Date(body.time.modified).toDateString()}`, true)
      .addField('Dependencies', `${deps && deps.length ? deps.join(", ") : "None"}`, true)
			.addField('Main File', version.main || 'index.js', true)
		return options.message.reply({ embeds: [embed] });
} catch (err) {
        console.log(`Error Occured | NPM | Error: ${err.stack}`)
    }

	}