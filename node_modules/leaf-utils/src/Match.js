const currentGames = new Object();
const Discord = require('discord.js');
const functions = require('../functions');

module.exports = async (options) => {
try {
  if (!options.message) {
		throw new Error('Leaf-utils: message argument was not specified.');
	}
	if (typeof options.message !== 'object') {
		throw new TypeError('Leaf-utils: Invalid Discord Message was provided.');
	}

	if (!options.embed) options.embed = {};
	if (typeof options.embed !== 'object') {
		throw new TypeError('Leaf-utils: embed must be an object.');
	}

	if (!options.embed.title) {
		options.embed.title = 'Football Match';
	}
	if (typeof options.embed.title !== 'string') {
		throw new TypeError('Leaf-utils: embed title must be a string.');
	}

  if (!options.buttons) options.buttons = {};
	if (typeof options.buttons !== 'object') {
		throw new TypeError('Leaf-utils: buttons must be an object.');
	}

	if (!options.buttons.left) {
		options.buttons.left = 'Left';
	}
	if (typeof options.buttons.left !== 'string') {
		throw new Error('Leaf-utils: left button text must be a string.');
	}

	if (!options.buttons.middle) {
		options.buttons.middle = 'Middle';
	}

  if (typeof options.buttons.middle !== 'string') {
		throw new Error('Leaf-utils: middle button text must be a string.');
	}

	if (!options.buttons.right) {
		options.buttons.right = 'Right';
	}
	if (typeof options.buttons.right !== 'string') {
		throw new Error('Leaf-utils: right button text must be a string.');
	}

  if (!options.emojis) options.emojis = {};
	if (typeof options.emojis !== 'object') {
		throw new TypeError('Leaf-utils: emojis must be an object.');
	}

  if (!options.emojis.goalkeeper) options.emojis.goalkeeper = 'üßç‚Äç‚ôÇÔ∏è';
	if (typeof options.emojis.goalkeeper !== 'string') {
		throw new TypeError('Leaf-utils: goalkeeper must be a string.');
	}

  if (!options.emojis.goal) options.emojis.goal = 'ü•Ö';
	if (typeof options.emojis.goal !== 'string') {
		throw new TypeError('Leaf-utils: goal must be a string.');
	}

  if (!options.emojis.soccer) options.emojis.soccer = '‚öΩ';
	if (typeof options.emojis.soccer !== 'string') {
		throw new TypeError('Leaf-utils: soccer must be a string.');
	}

  	if (!options.winMessage) {
		options.winMessage =
			'GG, <@{{winner}}> scored in **{{time}} seconds**.';
	}
	if (typeof options.winMessage !== 'string') {
		throw new TypeError('Leaf-utils: startMessage must be a string.');
	}

  if (!options.loseMessage) {
		options.loseMessage =
			'<@{{player}}> You lose';
	}
	if (typeof options.loseMessage !== 'string') {
		throw new TypeError('Leaf-utils: loseMessage must be a string.');
	}

  if (!options.ongoingMessage) {
		options.ongoingMessage =
			'A game is already runnning in <#{{channel}}>. You cant start a new one';
	}
	if (typeof options.ongoingMessage !== 'string') {
		throw new TypeError('Leaf-utils: ongoingMessage must be a string.');
	}

  if (!options.othersMessage) {
		options.othersMessage = 'Only <@{{author}}> can use buttons!';
	}
	if (typeof options.othersMessage !== 'string') {
		throw new TypeError('Leaf-utils: othersMessage must be a string.');
	}

	if (!options.embed.color) options.embed.color = functions.randomHexColor();
	if (typeof options.embed.color !== 'string') {
		throw new TypeError('Leaf-utils: embed color must be a string.');
	}

  if (currentGames[options.message.guild.id]) {
		const embed = new Discord.MessageEmbed()
			.setTitle(options.embed.title)
			.setColor(options.embed.color)
			.setDescription(
				options.ongoingMessage.replace(
					'{{channel}}',
					currentGames[`${options.message.guild.id}_channel`],
				),
			);
		return options.message.reply({ embeds: [embed] });
	}

  currentGames[options.message.guild.id] = true;
	currentGames[`${options.message.guild.id}_channel`] =
		options.message.channel.id;

const positions = {
			left: `_ _                   ${options.emojis.goal}${options.emojis.goal}${options.emojis.goal}\n_ _                   ${options.emojis.goalkeeper}\n      \n_ _                         ${options.emojis.soccer}`,
			middle: `_ _                   ${options.emojis.goal}${options.emojis.goal}${options.emojis.goal}\n_ _                        ${options.emojis.goalkeeper}\n      \n_ _                         ${options.emojis.soccer}`,
			right: `_ _                   ${options.emojis.goal}${options.emojis.goal}${options.emojis.goal}\n_ _                              ${options.emojis.goalkeeper}\n      \n_ _                         ${options.emojis.soccer}`,
		};

   let randomized = Math.floor(Math.random() * Object.keys(positions).length);
		let gameEnded = false;
		let randomPos = positions[Object.keys(positions)[randomized]];

		const componentsArray = [
			{
				type: 1,
				components: [
					{
						type: 2,
						style: 'PRIMARY',
						custom_id: 'left',
						label: options.buttons.left,
					},
					{
						type: 2,
						style: 'DANGER',
						custom_id: 'middle',
						label: options.buttons.middle,
					},
					{
						type: 2,
						style: 'PRIMARY',
						custom_id: 'right',
						label: options.buttons.right,
					},
				],
			},
		];

		const msg = await options.message.channel.send({
			content: randomPos,
			components: componentsArray,
		});
		function update() {
			randomized = Math.floor(Math.random() * Object.keys(positions).length);
			randomPos = positions[Object.keys(positions)[randomized]];

			msg.edit({
				content: randomPos,
				components: componentsArray,
			});
		}
		setInterval(() => {
			if(gameEnded == false) return update();
		}, 3000);

    const gameCreatedAt = Date.now();

		const filter = (button) => {
      if (button.user.id === options.message.author.id) return true;
    button.reply({
        content: options.othersMessage.replace(
					'{{author}}',
					options.message.member.id,
				),
        ephemeral: true
    });
    return false;
}
    
		const button = await msg.awaitMessageComponent({ filter: filter, componentType: 'BUTTON', max: 1 });
    

await button.deferUpdate();

		if(button.customId !== Object.keys(positions)[randomized]) {
			gameEnded = true;
			btn = new Discord.MessageButton()
				.setStyle('PRIMARY')
				.setLabel(options.buttons.left)
				.setCustomId('left')
				.setDisabled();
			btn2 = new Discord.MessageButton()
				.setStyle('DANGER')
				.setLabel(options.buttons.middle)
				.setCustomId('middle')
				.setDisabled();
    btn3 = new Discord.MessageButton()
				.setStyle('PRIMARY')
				.setLabel(options.buttons.right)
				.setCustomId('right')
				.setDisabled();

        const _embed = new Discord.MessageEmbed()
			.setTitle(options.embed.title)
					.setDescription(
						options.winMessage
							.replace('{{winner}}', button.user.id)
							.replace('{{time}}', (Date.now() - gameCreatedAt) / 1000),
					)
				.setColor(options.embed.color)
	
        await button.editReply({
				embeds: [_embed],
				components: [{ type: 1, components: [btn, btn2, btn3] }],
			});
   return delete currentGames[options.message.guild.id];
  	} 
		else {
			gameEnded = true;
						btn = new Discord.MessageButton()
				.setStyle('PRIMARY')
				.setLabel(options.buttons.left)
				.setCustomId('left')
				.setDisabled();
			btn2 = new Discord.MessageButton()
				.setStyle('DANGER')
				.setLabel(options.buttons.middle)
				.setCustomId('middle')
				.setDisabled();
    btn3 = new Discord.MessageButton()
				.setStyle('PRIMARY')
				.setLabel(options.buttons.right)
				.setCustomId('right')
				.setDisabled();

        const _embed = new Discord.MessageEmbed()
					.setTitle(options.embed.title)
					.setDescription(
						options.loseMessage
							.replace('{{player}}', button.user.id)
              .replace('{{time}}', (Date.now() - gameCreatedAt) / 1000),
					)
				.setColor(options.embed.color)
        await button.editReply({
				embeds: [_embed],
				components: [{ type: 1, components: [btn, btn2, btn3] }],
			});
  return delete currentGames[options.message.guild.id];
		}  
} catch (err) {
    console.log(`Error Occured. | Match | Error: ${err.stack}`);
  }
}